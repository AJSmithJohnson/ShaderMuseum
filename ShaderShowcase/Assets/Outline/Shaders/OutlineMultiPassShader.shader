// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "OutlineShaders/SilnoueteWithDiffuse"
{
	Properties
	{
		_Color("Main Color", Color) = (1,1,1,1)
		_OutlineColor("Outline Color", Color) = (0,0,0,1)
		_Outline("Outline amount", Range(-5, 5)) = 0.05
		_MainTex("Base (RGB)", 2D) = "white"{}
	}//End of properties block
	
	//Begin CGCODE
	CGINCLUDE //CG INCLUDE will insert the contents of the include into each pass of your shader
#include "UnityCG.cginc"
	struct appdata
	{
		float4 vertex : POSITION;
			float3 normal : NORMAL;
	};//End of appdata struct

	struct v2f
	{
		float4 pos : POSITION;
		float4 color: COLOR;
	};//End of v2f struct

	uniform float _Outline;//Variables that are uniform may only be specified from the program side not outside values are constant while drawing vertex and pixels
	uniform float4 _OutlineColor;

	v2f vert(appdata v)
	{
		v2f o;
		o.pos = UnityObjectToClipPos(v.vertex);//Transforms a point from object space to cameras space in homogeneous coordinates

		float3 norm = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);//Unity Matrix it mv transforms points from object to eye space, it mv rotates normals from object to eye space. WE have a float3 which is
		//created by mul() which is a function that multiplies x and y using matrix math
		//X being the unity matrix mv which we are casting to a 3by3 matrix of values and v.normal //We want to use the 3x3 version because we are transforming a direction
		//Otherwise translation gets added
		float2 offset = TransformViewToProjection(norm.xyz); //This takes part of the normal that is perpendicular to the view direction and projects it into clip space
		//Does not do a full matrix multiply,, it assumes there is a standard projection matrix

		o.pos.xy += offset * o.pos.z * _Outline;// o.pos which is the object in the cameras coordinates and we are adding to that offset which is the part of the normal 
		//That is perpendicular to view direction after transforming the object from object to eye space
		//Then we are multiplying that by the outline amount //This is all added to the positions xy coordinates
		o.color = _OutlineColor;//Then we set the vertex color equal to outline color
		return o;//return o
	}

	ENDCG//End this cg pass

		SubShader //NOW we create our subshader
	{
		Tags{"Queue" = "Transparent"}//We set our queue to transparent so that our object is rendered after geomety and alpha testing //Since this is 
		//declared above each pass we can assume that each of the passes will be rendered out in this queue
		Pass//We define our first pass
		{
			Name "OUTLINE" //This gives a pass name to the current pass, internally names are turned to upper case
			Tags {"LightMode" = "Always"} //The tag with light mode always means that the object will always be rendered and no lighting is applied
			//Keep in mind lightmode tags must always be inside a pass section and not inside a subshader
			Cull off //Disables back face culling which results in all faces of an object being drawn
			ZWrite off//Controls wiether or not objects are being drawn to the depth buffer or not
			ZTest Always //This is if depth testing should be performed, default is LEqual which means drawing objcts in front or at the distance as existing objects and hiding  objects behind them
			//So if an object is less than or equal it should be hidding, in the case of always I would assume that means everything is hidden behind this
			ColorMask RGB //Seting this turns of writting to some channels, in this case rgb are all off so all we can write to is A the alpha channel
			Blend SrcAlpha OneMinusSrcAlpha//Blending is performed after alpha and depth testing and is used to make transparent objects
			//In this case Blend SrcFacter DstFacter is used to configure and enable blending, Generated color is multiplied by the SrcFacter, color already on screen is multiplied by DSTfactor
			//And the two are added together
			//So SrCAlpha Take our src alpha and multiplies color generated by it, then takes color on screen and multiplies it by 1- the src alpha, this gives us traditional transparency


			CGPROGRAM//We start writting CG code here
			#pragma vertex vert//We define our vertex function
			#pragma fragment frag//We define our fragment function //BECAUSE we did CGINCLUDE Above the only function we actually need to create is our fragment function
			half4 frag(v2f i) : COLOR//COLOR is used by DX9 as the fragment out put semantic but is also used by several shader languages for mesh data and vertex output semantics, instead you see SV_Target more often but this means they can easily replace all instances of SV_Target with whatever is needed for each shader languages fragment output
			{
				return i.color;//WE return color
			}
			ENDCG//We stop writing CG
			}//End of Pass
				Pass//We create a new pass
			{
				Name "BASE"//This new pass has a name of base
				ZWrite On//ZWriting is on so we are writting to the depth buffer
				ZTest LEqual//ZTest is set to equal so that we compare and hide objects behind this one
				Blend SrcAlpha OneMinusSrcAlpha//We have traditional alpha capabilities with our blending
				Material//So We are defining a function called material
				{
					Diffuse[_Color]//This function has a diffuse property
					Ambient[_Color]//And an ambient color perperty
				}
				Lighting On //We set lighting to b on
				SetTexture[_MainTex]{ //We create a function to set the MainTexture property
					ConstantColor[_Color] //We create a constant color
					Combine texture * constant //We combine the texture with the constant color
				}
				SetTexture[_MainTex]{//Seeing as this is declared again we can assume this is used to set the texture and is some sort of built in cg function
				Combine previous * primary DOUBLE//Here we are combining the previous texture with the primary texture twice? 
				}
			}//End of Pass
	}//End of subshader

		SubShader{ //We create another subshader with another two passes in it
				Tags{"Queue" = "Transparent"}
				Pass{
					Name "OUTLINE"
					Tags {"LightMode" = "Always"}
					Cull Front
					ZWrite Off
					ZTest Always
					ColorMask RGB

					Blend SrcAlpha OneMinusSrcAlpha
					CGPROGRAM
					#pragma vertex vert
					#pragma exclude_renderers gles xbox360 ps3
					ENDCG
					SetTexture[_Maintex] {combine primary}
				}
				Pass{
					Name "BASE"
					ZWrite On
					ZTest LEqual
					Blend SrcAlpha OneMinusSrcAlpha
					Material{
						Diffuse[_Color]
						Ambient[_Color]
					}
					Lighting On
					SetTexture[_MainTex]{
						ConstantColor[_Color]
						Combine texture * constant
					}
					SetTexture[_MainTex]{
						Combine previous * primary DOUBLE
					}
				}	
			}
				Fallback "Diffuse"
}//End of actual shader